### Математические структуры.

#### Кузнецов Владимир Михайлович, ФКН.

---

##### <p align=center> Контрольная работа 1. Вариант 2.<p>

---

**Задача 1.** Пусть функции $f(x)$ и $g(x)$ примитивно рекурсивны. Докажите примитивную рекурсивность функции
$$
f(x) =
\begin{cases}
1, & \text{if } \exists y, z \leq x : g(y) = h(z), \\
0, & \text{else}.
\end{cases}
$$

---

$\triangleright\quad$ Давайте изначально введём предикат $P(x, y, z)$ такой, что его характеристическая функция $\chi_{P}(x, y, z) = 1 \Leftrightarrow g(y) = h(z)$. Легко видно, что эта характеристическая функция примитивно рекурсивна, так как функции $f(x)$ и $g(x)$ примитивно рекурсивны, а так же предикат $=$ примитивно рекурсивен.

Вообще говоря, заметим, что $f(x)$ тоже является предикатом. Так что нам нужно доказать, примитивную рекурсивность следующего: $\exists y, z \leq x P(x , y, z)$. Для доказательства этого давайте введём ещё один предикат $R(x, y) \Leftrightarrow \exists z \leq x P(x, y, z)$. Он примитивно рекурсивен, так как класс примитивно рекурсивных предикатов замкнут относительно операций ограниченного квантифицирования и $P(x, y, z)$ примитивно рекурсивен.

Теперь можем заметить, что $\exists y, z \leq x P(x , y, z) \Leftrightarrow \exists y \leq x R(x, y)$. При этом $R(x, y)$ примитивно рекурсивен как было доказано ранее, и повторимся, что класс примитивно рекурсивных предикатов замкнут относительно операций ограниченного квантифицирования, а значит и $f(x)$ примитивно рекурсивна. $\quad\square$

---

Мем, призванный закрыть пустоту на страничке:

<img src="/Users/cdraugr-/Desktop/HSE/MathStructs/ComputabilityComplexity/HomeAssignment2/image01.jpg" alt="image01" style="zoom:25%;" />

---

**Задача 2.** Рассмотрим следующую частично рекурсивную функцию
$$
f(x) = \mu y (g(y) = x) = \mu y P(x, y),
$$
полученную минимизацией предиката $P (x, y) \Leftrightarrow (g(y) = x)$ по переменной $y$, где
$$
g(y) = \begin{cases}
5 \dot - y, & y \ne 3, \\
\uparrow, & y = 3.
\end{cases}
$$
Опишите функцию $f(x)$ явно, т.е. укажите, в каких точках эта функция определена, и какое значение она принимает в каждой из таких точек.

---

Изначально давайте явно опишем функцию $g(x)$:

| $y$    | $0$ | $1$ | $2$ | $3$        | $4$ | $5$ | $\geq 6$ |
|--------|-----|-----|-----|------------|-----|-----|----------|
| $g(y)$ | $5$ | $4$ | $3$ | $\uparrow$ | $1$ | $0$ | $0$      |

Сразу видно, что $\forall x \in \{0, 1, 3, 4, 5\} \subset \N$  предикат $P(x, y)$ может принимать значение единицу, а для других натуральных он всегда ноль (или $\uparrow$).

Теперь можем явно описать функцию $f(x)$, но будем помнить, что оператор минимизации начнет по очереди подставлять в функцию $y$, и на значении $3$ он зациклится и дальше ничего не сможет подставлять:

|  $x$   |    $0$     |    $1$     |    $2$     | $3$  | $4$  | $5$  |  $\geq 6$  |
| :----: | :--------: | :--------: | :--------: | :--: | :--: | :--: | :--------: |
| $f(x)$ | $\uparrow$ | $\uparrow$ | $\uparrow$ | $2$  | $1$  | $0$  | $\uparrow$ |

---

**Задача 3.** Верно ли, что если вычисление машины Тьюринга $M$ не завершается (т.е. машина $M$ зацикливается), то она обязательно посещает некоторую конфигурацию дважды?

---

Нет, контрпример:

Рассмотрим $\Gamma = \{\#, 1\}$, где $\#$ $-$ пробельный символ. А также
$$
Q := \{q_0 \# \to q_0 1 R, q_0 1 \to q_f, q_f\}.
$$
Такая машина останавливается, если на вход дано какое-то непустое слово. При этом, если на вход она получает пустое слово, и мы считаем, что на ленте нет "мусора", то вычисление зацикливается. При этом, после каждой её итерации мы будем получать новое состояние ленты, а значит, и новую конфигурацию. Давайте распишем несколько первых шагов программы на пустом входе. Нижним подчёркиванием я буду обозначать положение головки:
$$
(q_0, \ldots \#\underline \#\#\# \ldots) \to (q_0, \ldots \# 1\underline \#\# \ldots) \to (q_0, \ldots \#11\underline \# \ldots) \to \ldots
$$
После $i$-ой итерации (после $i$-ой стрелочки [нумерация с единицы]) на ленте будет $i$ единичек, при этом побывав на $i$-ой итерации единожды, второй раз мы на неё вернёмся, а значит, каждое такое состояние уникально и машина никогда не посещает некоторую конфигурацию дважды.

---

**Задача 4.** Докажите, что множество всех натуральных чисел, которые представляются в виде разности двух квадратов натуральных чисел рекурсивно перечислимо.

---

$\triangleright\quad$ Давайте изначально рассмотрим все натуральные числа, которые представимы в виде разности двух натуральных: $n = x^2 - y^2 = (x - y)(x + y)$. При этом, числа $x-y$ и $x + y$ имеют одинаковую чётность, а значит, $n$ делится на $4$, либо имеет вид $4k\pm 1$. Теперь докажем, что все натуральные числа таких видов представимы в виде $4k$ или $4k\pm 1$, представимы в виде разности двух натуральных:

1. $n = 4k = x^2 - y^2$.

   Возьмём $x = k - 1$, $y = k + 1$, тогда $(k-1-k-1)(k-1+k+1) = 4k$. Стоит уточнить, что для $n = 0$ надо взять $x = 0 = y$.

2. $n = 2k+1 = x^2 - y^2$. (Этот случай покрывает все выражения вида $4k \pm 1$).

   Возьмём $x = k + 1$, $y = k$, тогда $(k+1-k)(k+1+k) = 2k+1$.

Так мы показали включение в обе стороны, а значит, мы показали, что натуральное число представимо в виде разности двух натуральных тогда и только тогда, когда оно не представимо в виде $4k+ 2$ для какого-то натурального $k$. 

Уже становится достаточно понятно, что будет происходить далее. Мы помним, что множество натуральных чисел рекурсивно перечислимо, тогда, давайте перечислять его, но не будем выводить те элементы, которые представимы ввиде $4k+2$. Проверку на принадлежность к таким элементам организуем в виде простого предиката:
$$
P(n) \iff \exists k \leq n (4\cdot k + 2 = n).
$$
Тогда, перечислять данное множество можно следующим образом:

```pseudocode
function printA():
	for n from 0 to inf:
		if P(n) then
			print(n)
		else
			do nothing
```

---

<div style="page-break-after: always;"></div>

#####<p align=center> Домашнее задание 2. Вариант 2.<p>

---

**Задание 1.** Пусть $f : \N \to \N$ тотальная вычислимая функция. Докажите, что множество всех натуральных чисел $x$ таких, что $f(y) < f(x)$ для некоторого $y > x$, является рекурсивно перечислимым.

---

$\triangleright\quad$ Давайте переформулируем задачу, чтобы нам не пришлось ломать голову, что от нас хотят: нам нужно перечислить множество
$$
A = \{x\in \N | \exists y \in \N, y > x : f(y) < f(x)\}.
$$
Теперь давайте заметим, что
$$
y < x \Leftrightarrow \neg (x \dot - y = 0).
$$
Отрицание, предикат "равенство", усеченное вычитание $-$ рекурсивны, значит и предикат "меньше" такой. Т.е. этот предикат остановится на любых входных данных. Давайте введём вспомогательный "тотально вычислимый" предикат $P(x, y) \Leftrightarrow f(y) < f(x)$. $f : \N \to \N$ тотальная вычислимая функция, как и "меньше", так что предикат определён на любой упорядоченной паре натуральных чисел $(x, y)$.

Когда стало ясней о чём вообще речь, давайте подумаем и сделаем хитрей, чем хочется это сделать изначально. Мы знаем, что множество натуральных чиселок рекурсивно перечислимо. Это нам позволяет пройтись не по $x$, как хотелось бы, а по $y$. Поясню псевдокодом, а потом словами:

```pseudocode
function printA():
	for y from 1 to inf:
		for x from 0 to y - 1:
			if P(x, y) then
				print(x)
			else
				do nothing
```

Тут всё достаточно понятно, но уверен, что стоит пояснить. Мы проходим по всем $y \in \N \setminus \{0\}$ ($0$ я исключаю, так как $\nexists x \in \N : x < 0$) и для каждого такого $y$ ищем $x$, который мог бы лежать в $A$. Если он лежит в $A$, то мы его печатаем и переходим к следующему числу, если не лежит, то не печатаем и всё равно переходим к следующему числу. И так пока $x \ne y$. Т.е. мы пробегаем по всем $x < y$. Так мы можем перечислить всё множество $A$, потому что мы пробегаем по всевозможным теоретически подходящим $y$. $\quad\square$

---

<div style="page-break-after: always;"></div>

**Задача 2.** Пусть $A \subseteq \N$ рекурсивно перечислимо, а $B \subseteq \N$ рекурсивно. Докажите, что множество $A \cap B$ рекурсивно перечислимо. Приведите пример рекурсивно перечислимого множества $A$ и рекурсивного множества $B$, для которых множество $A \cap B$ не рекурсивно.

---

1. $\triangleright\quad$ Будем перечислять $A$, для каждого его элемента $a$ вызываем $\chi_B(a)$ , если характеристическая функция вернула единицу, то $a$ лежит и в $B$, а значит, надо его напечатать. Если же, характеристическая функция вернула $0$, то не печатаем число. В пересечении элементов не из $A$ быть не может, значит мы выведем все элементы из $A \cap B$. $\quad\square$

2. Мы только что доказали, что $A \cap B$ обязательно в таком случае рекурсивно перечислимо. Давайте вспомним, какие мы знаем рекурсивно перечислимые не рекурсивные множества.

   Зададим $A = \{x \in \N | \varphi_x(2x)\downarrow\} \subseteq \N$, это множество рекурсивно перечислимо и не рекурсивно (с конспектов лекций). А так же зададим множество $B = \N \subseteq \N$. Это множество, очевидно, рекурсивно, так как явно можем описать $\chi_B(x) \iff 1$. Тогда, обратим внимание на пересечение этих двух множеств:
   $$
   A \cap B = \{x\in \N | \varphi_{x}(2x) \downarrow\} = A.
   $$
   Получили исходное множество $A$, про которое мы знаем, что оно не рекурсивно, а значит, $A$ и $B$ $-$ искомые множества.

---

**Задача 3.** Функция $f : \N \to \N$ называется строго возрастающей на множестве $B \subseteq \N$, если $f$ определена на множестве $B$ и для любых $x, y \in B$, если $x < y$, то $f(x) < f(y)$. Докажите, что множество $A = \{x | \varphi_x$ не является строго возрастающей на $W_x\}$, где $W_x = \text{dom}\varphi_x$, рекурсивно перечислимо, но не рекурсивно.

---

$\triangleright\quad$ Для доказательства р.п. множества $A$ воспользуюсь эквивалентным определением р.п. и покажу,
что $A$ является проекцией рекурсивного множества:

$x \in A \iff \exists y, z, k\ (y < z$ и вычисления $\varphi_x(y)$ и $\varphi_x(z)$ завершаются (не более чем) за $k$ шагов с результатом $\varphi_x(y) \geq \varphi_x(z)$). Иными словами:
$$
x \in A \iff \exists y, z \in W_x, y < z : \varphi_x(z) \leq \varphi_x(y).
$$
Теперь предположим, что это множество рекурсивно, тогда существует $\chi_A(x)$, которая определена на всех входах. Достаточно ясно, что это ложь и провокация, но давайте немного скажем слов (не доказывать же $m$-сводимость к $K$ :) ). Пусть у меня есть функция $f(x)$, которая делает следующее, она на всех входах (кроме $f(1)$) возращает само число $x$. При этом, на входе $1$ она с вероятностью $1/2$ возвращает число $2$ (за какое-то большое число шагов), а с вероятностью $1/2$ зацикливается. Отмечу, что она запоминает какие числа ей уже давались и на одном и том же входе ведёт себя одинаково. У этой функции есть номер в главной нумерации, при этом, если она является строго возрастающей (т.е. всё же зацикливается на единице), то мы об этом никогда не узнаем, т.е. не сможем сделать вывод о её принадлежности к $A$. $\quad\square$

---

**Задача 4.** Докажите, что множество $A = \{\langle x, y\rangle | W_x \cup W_y\ne \varnothing\}$ рекурсивно перечислимо и $K \leq_m A$, где $K = \{x | \varphi_x(x)\downarrow\}$.

---

$\triangleright\quad$ Для доказательства р.п. множества $A$ воспользуюсь эквивалентным определением р.п. и покажу,
что $A$ является проекцией рекурсивного множества:<br><p align=center>$\langle x, y \rangle \in A \iff \exists z, k\ ($вычисления $\varphi_x(z)$ или $\varphi_y(z)$ завершаются<br> (не более чем) за $k$ шагов).<p>

Теперь давайте докажем $m$-сводимость:
$$
K \leq _m A \iff (\exists f(x) : x\in K \iff f(x) \in A).
$$
Определим $f(x)$ как $f(x) = \langle \text{id}(g), \text{id}(g) \rangle$, где

```pseudocode
function g(t):
	if t != x then
		while true
			do nothing
	else
		return \varphi_x(x)
```

"По-питоновски" функции $f$ и $g$ можно записать примерно так:

```python
def g(x: int, t: int) -> int:
    if x != t:
        while True:
            pass
    return varphi_x(x)

def f(x: int) -> int:
    return < id(lambda t : g(x, t)), id(lambda t : g(x, t)) >
```

<p align=center>$x \in K \Rightarrow \varphi_x(x)\downarrow\Rightarrow $ функция $g(t)$ определена на входе $x \Rightarrow W_{\text{id}(g)} \ne \varnothing \Rightarrow f(x) \in A$,<br>$x \notin K \Rightarrow \varphi_x(x) \uparrow \Rightarrow $ функция $g(t)$ нигде не определена $\Rightarrow W_{\text{id}(g)} = \varnothing \Rightarrow f(x) \notin A$. $\quad\square$<p>

---